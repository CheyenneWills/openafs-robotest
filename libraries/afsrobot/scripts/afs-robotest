#!/usr/bin/env python
# Copyright (c) 2015-2016 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import logging
import gettext
import os
import sys
import logging
import traceback

import afsrobot.config
import afsrobot.ssh
import afsrobot.web
import afsrobot.runner

import afsutil.system

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)

logger = logging.getLogger('afsrobot')

#
# Environment Variables
#
# AFS_ROBOTEST_ROOT  Path to the test and output directories.
#                    Defaults to the current working directory.
#                    Overridden by the path:root configuration value.
#
# AFS_ROBOTEST_CONF  Fully qualified filename of the configuration file.
#                    Defaults to ~/.afsrobotestrc/afs-robotest.conf
#                    Overridden by the --config (-c) command line option.
#
AFS_ROBOTEST_ROOT = os.getenv('AFS_ROBOTEST_ROOT', os.getcwd())
AFS_ROBOTEST_CONF = os.getenv('AFS_ROBOTEST_CONF',
                      os.path.join(
                        os.environ['HOME'], '.afsrobotestrc', 'afs-robotest.conf'))

#
# version sub-command
#
def cmd_version(c):
    sys.stdout.write("Version %s\n" % (afsrobot.__version__))

#
# config sub-commands
#
def cmd_config_init(c):
    filename = c.args.config
    root = c.args.root
    config = afsrobot.config.Config()
    config.load_defaults()
    if os.path.exists(filename):
        msg = "Updating"
        config.load_from_file(filename)
    else:
        msg = "Creating"
        config.set_value('paths', 'root', root)
    dirname = os.path.dirname(filename)
    if not os.path.exists(dirname):
        c.say("Making directory %s" % (dirname))
        os.makedirs(dirname)
    c.say("%s config file %s" % (msg, filename))
    config.save_as(filename)

def cmd_config_copy(c):
    c.say("Copying to file %s." % (args.dest))
    new_config = afsrobot.config.Config()
    new_config.load_from_file(config.filename)
    new_config.save_as(args.dest)

def cmd_config_list(c):
    c.config.print_values(section=c.args.section, raw=c.args.raw)

def cmd_config_set(c):
    try:
        c.config.set_value(c.args.section, c.args.option, c.args.value)
        c.config.save()
    except Exception as e:
        sys.stderr.write("Unable to set: %s\n" % (e))
        return 1

def cmd_config_unset(c):
    try:
        c.config.unset_value(c.args.section, c.args.option)
        c.config.save()
    except Exception as e:
        sys.stderr.write("Unable to remove: %s\n" % (e))
        return 1

#
# web sub-commands
#
def cmd_web_start(c):
    afsrobot.web.TinyWebServer(c.config).start()

def cmd_web_stop(c):
    afsrobot.web.TinyWebServer(c.config).stop()

def cmd_web_status(c):
    server = afsrobot.web.TinyWebServer(c.config)
    sys.stdout.write("%s\n" % (server.status()))

#
# ssh sub-commands
#
def cmd_ssh_create(c):
    rc = afsrobot.ssh.generate_key(c.args.keyfile)
    if rc == 0:
        c.config.set_value('ssh', 'keyfile', c.args.keyfile)
        c.config.save()
    return rc

def cmd_ssh_dist(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.distribute_key(keyfile, hostnames)

def cmd_ssh_check(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.check_access(keyfile, hostnames)

def cmd_ssh_exec(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.execute(keyfile, hostnames, c.args.command)

def cmd_setup(c):
    r = afsrobot.runner.Runner(c.config)
    r.setup(**vars(c.args))

def cmd_login(c):
    r = afsrobot.runner.Runner(c.config)
    r.login(**vars(c.args))

def cmd_test(c):
    r = afsrobot.runner.Runner(c.config)
    r.test(**vars(c.args))

def cmd_teardown(c):
    r = afsrobot.runner.Runner(c.config)
    r.teardown(**vars(c.args))


class SubCommandContext(object):
    """Common pre and post processing for each sub-command."""
    def __init__(self, args):
        self.args = args
        # Avoid 'file not found' error when running 'config init'.
        self._defer_config = getattr(args, '_defer_config', False)
        self._logname = getattr(args, '_logname', None)
        self.config = None

    def _read_config(self, filename):
        if not os.path.exists(filename):
            raise ValueError("Config file '%s' not found." % (filename))
        self.say("Loading config file %s." % (filename))
        self.config = afsrobot.config.Config()
        self.config.load_from_file(filename)

    def _setup_log(self, config, logname):
        if logname:
            if config:
                logdir = os.path.abspath(self.config.optstr('paths', 'log', '.'))
            else:
                logdir = os.getcwd()
            if not os.path.isdir(logdir):
                os.makedirs(logdir)
            self._logfile = os.path.join(logdir, logname)
            sys.stdout.write("Writing to log file %s\n" % (self._logfile))
            fmt = '%(asctime)s %(levelname)s %(message)s'
            logging.basicConfig(level=logging.INFO, filename=self._logfile, format=fmt)
        else:
            fmt = '%(message)s'
            logging.basicConfig(level=logging.INFO, format=fmt)
        if self.args.verbose:
           console = logging.StreamHandler()
           console.setLevel(logging.INFO)
           formatter = logging.Formatter('%(message)s')
           console.setFormatter(formatter)
           logging.getLogger('').addHandler(console) # add to the root logger

    def __enter__(self):
        if not self._defer_config:
            self._read_config(self.args.config)
        self._setup_log(self.config, self._logname)
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is not None and self._logfile:
            sys.stdout.write("See log file %s\n" % (self._logfile))
            if exc_type is afsutil.system.CommandFailed:
                logger.error("Command failed: %s, code %d\n" % (exc_value.cmd, exc_value.code))
                logger.error("output:\n")
                logger.error("%s\n" % (exc_value.out))
                logger.error("error:\n")
                logger.error("%s\n" % (exc_value.err))
            else:
                for line in traceback.format_exception(exc_type, exc_value, tb):
                    logger.error(line.rstrip('\n'))
        return False

    def say(self, msg):
        if self.args.verbose:
            sys.stdout.write("%s\n" % (msg))

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def main():
    """Command line handling for the afs-robotest tool."""

    def common_options(p):
        p.add_argument('-c', '--config', metavar='<filename>',
                       help="config file (default: %s)" % AFS_ROBOTEST_CONF,
                       default=AFS_ROBOTEST_CONF)
        p.add_argument('-v', '--verbose', help="run verbosely", default=False, action='store_true')

    # This should be run as a normal user; sudo is called for installation as needed.
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % (sys.argv[0]))
        sys.exit(1)

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="commands", metavar="<command>")

    #
    # afs-robotest version
    #
    p = subparsers.add_parser('version', help="print version information")
    common_options(p)
    p.set_defaults(_cmd=cmd_version, _defer_config=True)

    #
    # afs-robotest config
    #
    p = subparsers.add_parser('config', help="get or set configuration")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('init', help="create a config file with default values")
    common_options(p)
    p.add_argument('--root', help="afs-rototest root directory (default: %s)" % (AFS_ROBOTEST_ROOT),
                   default=AFS_ROBOTEST_ROOT)
    p.set_defaults(_cmd=cmd_config_init, _defer_config=True)

    p = ssp.add_parser('copy', help="copy configuration values to a new file")
    common_options(p)
    p.add_argument('dest', metavar='<tofile>', help="destination filename")
    p.set_defaults(_cmd=cmd_config_copy)

    p = ssp.add_parser('list', help="show configuration values")
    common_options(p)
    p.add_argument('-r', '--raw', action='store_true', help="do not expand interpolated values")
    p.add_argument('-s', '--section', help="config section")
    p.set_defaults(_cmd=cmd_config_list)

    p = ssp.add_parser('set', help="set a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.add_argument('value', metavar='<value>', help="option value")
    p.set_defaults(_cmd=cmd_config_set)

    p = ssp.add_parser('unset', help="unset a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.set_defaults(_cmd=cmd_config_unset)

    #
    # afs-robotest ssh
    #
    p = subparsers.add_parser('ssh', help="manage ssh keys and run commands")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('create', help="generate a ssh key pair")
    common_options(p)
    keyfile = os.path.join(os.environ['HOME'], '.ssh', 'afs-robotest')
    p.add_argument('--keyfile', help="ssh keyfile name (default: %s)" % (keyfile), default=keyfile)
    p.add_argument('-t', dest='keytype', metavar='<type>', help="ssh key type (default: rsa)", default='rsa')
    p.set_defaults(_cmd=cmd_ssh_create)

    p = ssp.add_parser('dist', help="distribute the ssh public key to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_dist)

    p = ssp.add_parser('check', help="check passwordless ssh access to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_check)

    p = ssp.add_parser('exec', help="execute a command on each remote host")
    common_options(p)
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-q', '--quiet', action='store_true', help="do not print hostnames")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('command', help='command line')
    p.set_defaults(_cmd=cmd_ssh_exec)

    #
    # afs-robotest web
    #
    p = subparsers.add_parser('web', help="run the test report web server")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('start', help="start web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_start)

    p = ssp.add_parser('stop', help="stop web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_stop)

    p = ssp.add_parser('status', help="show web server status")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_status)

    #
    # afs-robotest setup
    #
    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.add_argument('--force', action='store_true', help='overwrite existing files', default=None)
    p.set_defaults(_cmd=cmd_setup, _logname='setup.log')

    #
    # afs-robotest run
    #
    p = subparsers.add_parser('test', help="run the tests")
    common_options(p)
    p.add_argument('-s', '--suite', help="test suite to run (default: all)", default=None)
    p.add_argument('-i', '--include', help="test tags to include (default: all)", default=None)
    p.set_defaults(_cmd=cmd_test)
    # Alias for 'test' for compatibility with old versions.
    if len(sys.argv) > 1 and sys.argv[1] == 'run':
        sys.argv[1] = 'test'

    #
    # afs-robotest login
    #
    p = subparsers.add_parser('login', help="obtain a token")
    common_options(p)
    p.add_argument('-u', '--user', help="user name (default: admin)", default=None)
    p.set_defaults(_cmd=cmd_login, _logname='login.log')

    #
    # afs-robotest teardown
    #
    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.set_defaults(_cmd=cmd_teardown, _logname='teardown.log')

    rc = 0
    args = parser.parse_args()
    try:
        with SubCommandContext(args) as c:
            rc = args._cmd(c)
    except afsutil.system.CommandFailed as e:
        sys.stderr.write("Command failed: %s, code %d\n" % (e.cmd, e.code))
        sys.stderr.write("output:\n")
        sys.stderr.write("%s\n" % (e.out))
        sys.stderr.write("error:\n")
        sys.stderr.write("%s\n" % (e.err))
        if rc == 0:
            rc = 1
    except Exception as e:
        sys.stderr.write("%s\n" % (e))
        if rc == 0:
            rc = 1
    finally:
        pass
    return rc

if __name__ == "__main__":
    sys.exit(main())

