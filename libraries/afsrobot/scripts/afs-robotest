#!/usr/bin/env python
# Copyright (c) 2015-2016 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import gettext
import os
import subprocess
import shlex
import sys

import afsrobot.config
import afsrobot.command
import afsrobot.ssh
import afsrobot.web

try:
    import robot.run
except ImportError:
    sys.stderr.write("Cannot import robotframework packages.\n")
    sys.stderr.write("Install robotframework with `sudo pip install robotframework`.\n")
    sys.exit(1)

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)

def mkdirp(path):
    """Make a directory with parents.
    Do not raise an execption if the directory already exists."""
    if not os.path.isdir(path):
        os.makedirs(path)

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def start(msg):
    sys.stdout.write(msg.ljust(61, '.'))
    sys.stdout.write(' ')
    sys.stdout.flush()

def fail(msg):
    sys.stdout.write("fail\n%s\n" % (msg))
    sys.stdout.flush()
    sys.exit(1)

def ok():
    sys.stdout.write("ok\n")
    sys.stdout.flush()


def cmd_config_init(args, config):
    """Create the initial config file."""
    filename = args.newconfig
    if filename is None:
        filename = config.filename
    if filename is None:
        filename = afsrobot.config.AFS_ROBOTEST_CONF
    if not os.access(filename, os.F_OK):
        with open(filename, "w") as f:
            config.write(f)

def cmd_config_list(args, config):
    """List the current configuration."""
    def print_section(s):
        sys.stdout.write("[%s]\n" % s)
        for k,v in config.items(s):
            sys.stdout.write("%s = %s\n" % (k, v))
        sys.stdout.write("\n")

    if config.filename:
        sys.stdout.write("# file: %s\n\n" % (config.filename))
    if args.section:
        if not config.has_section(args.section):
            sys.stderr.write("Section not found: %s\n" % (args.section))
            return 1
        print_section(args.section)
    elif args.expand:
        for s in config.sections():
            print_section(s)
    else:
        config.write(sys.stdout)

def cmd_config_set(args, config):
    """Set a value in the config file.

    This will create the config file if it does not exist. Use --newconfig to set
    the name of an alternate configuration file to write."""
    if args.section not in config.sections():
        config.add_section(args.section)
    config.set(args.section, args.option, args.value)
    filename = args.newconfig
    if filename is None:
        filename = config.filename
    if filename is None:
        filename = afsrobot.config.AFS_ROBOTEST_CONF
    with open(filename, 'w') as f:
        config.write(f)


def cmd_setup(args, config):
    """Setup OpenAFS client and servers and create a test cell."""
    aklog_workaround_check(args, config)

    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    logfile = os.path.join(config.optstr('paths', 'log', '.'), "setup.log")
    mkdirp(os.path.dirname(logfile))
    if os.path.exists(logfile):
        os.remove(logfile)

    def log(msg):
        with open(logfile, 'a') as f:
            f.writelines(["localhost", " ", "INFO", " ", msg, "\n"])

    sys.stdout.write("Running setup.\n")
    sys.stdout.flush()
    log("==== SETUP ====")

    # Install
    for hostname in config.opthostnames():
        cmd = afsrobot.command.Command(hostname, keyfile, logfile=logfile)
        section = "host:%s" % (hostname)
        installer = config.optstr(section, 'installer', default='none')
        if installer == 'transarc' or installer == 'rpm':
            start("Installing on %s" % (hostname))
            if config.optbool('kerberos', 'akimpersonate'):
                if cmd.afsutil('fakekey', *config.optfakekey()) != 0:
                    fail("Failed to create fake service key; see %s\n" % (logfile))
            if cmd.afsutil('install', *config.optinstall(hostname)) != 0:
                fail("Failed to install; see %s\n" % (logfile))
            ok()
        elif installer == 'none':
            log("Skipping install on hostname %s; installer is 'none'." % (hostname))
        else:
            fail("Invalid installer option for hostname %s!; installer='%s'." % (hostname, installer))

    # Set key
    for hostname in config.opthostnames():
        cmd = afsrobot.command.Command(hostname, keyfile, logfile=logfile)
        section = "host:%s" % (hostname)
        installer = config.optstr(section, 'installer', default='none')
        if installer == 'none':
            log("Skipping setkey on hostname %s; installer is 'none'." % (hostname))
            continue
        if cmd.afsutil('setkey', *config.optsetkey(hostname)) != 0:
            fail("Failed to setkey; see %s\n" % (logfile))

    # Start clients and servers.
    for hostname in config.opthostnames():
        cmd = afsrobot.command.Command(hostname, keyfile, logfile=logfile)
        section = "host:%s" % (hostname)
        if config.optbool(section, "isfileserver") or config.optbool(section, "isdbserver"):
            start("Starting servers on %s" % (hostname))
            if cmd.afsutil('start', 'server') != 0:
                fail("Failed to start servers; see %s\n" % (logfile))
            ok()
        if config.optbool(section, "isclient") and config.optbool(section, 'afsdb_dynroot', default=True):
            start("Starting client on %s" % (hostname))
            if cmd.afsutil('start', 'client') != 0:
                fail("Failed to start client; see %s\n" % (logfile))
            ok()

    cmd = afsrobot.command.Command('localhost', keyfile, logfile=logfile, verbose=args.verbose)
    start("Setting up new cell")
    if cmd.afsutil('newcell', *config.optnewcell()) != 0:
        fail("Failed to setup cell; see %s\n" % (logfile))
    ok()

    # Now that the root volumes are ready, start any non-dynroot clients.
    for hostname in config.opthostnames():
        cmd = afsrobot.command.Command(hostname, keyfile, logfile=logfile)
        section = "host:%s" % (hostname)
        if config.optbool(section, "isclient") and not config.optbool(section, 'afsdb_dynroot', default=True):
            start("Starting non-dynroot client on %s" % (hostname))
            if cmd.afsutil('start', 'client') != 0:
                fail("Failed to start client; see %s\n" % (logfile))
            ok()
    return 0

def cmd_login(args, config):
    logfile = os.path.join(config.optstr('paths', 'log', '.'), "login.log")
    mkdirp(os.path.dirname(logfile))
    if os.path.exists(logfile):
        os.remove(logfile)
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    cargs = config.optlogin(args.user)
    if '--user' in cargs:
        user = cargs[cargs.index('--user') + 1]
    else:
        user = 'admin'
    cmd = afsrobot.command.Command('localhost', keyfile, logfile=logfile)
    start("Obtaining token for %s" % (user))
    rc = cmd.sh('afsutil', 'login', *cargs)
    if rc != 0:
        fail("Failed to login; see %s." % (logfile))
    ok()

def cmd_teardown(args, config):
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    logfile = os.path.join(config.optstr('paths', 'log', '.'), "teardown.log")
    mkdirp(os.path.dirname(logfile))
    if os.path.exists(logfile):
        os.remove(logfile)

    def log(msg):
        with open(logfile, 'a') as f:
            f.writelines(["localhost", " ", "INFO", " ", msg, "\n"])

    sys.stdout.write("Running teardown.\n")
    log("==== TEARDOWN ====")

    for hostname in config.opthostnames():
        section = "host:%s" % (hostname)
        cmd = afsrobot.command.Command(hostname, keyfile, logfile=logfile)
        installer = config.optstr(section, 'installer', default='none')
        if installer == 'transarc':
            start("Removing clients and servers on %s" % (hostname))
            if cmd.afsutil('stop', *config.optcomponents(hostname)) != 0:
                fail("Failed to stop; see %s\n" % (logfile))
            if cmd.afsutil('remove', '--purge') != 0:
                fail("Failed to remove; see %s\n" % (logfile))
            ok()
        elif installer == 'none':
            log("Skipping remove on hostname %s; installer is 'none'." % (hostname))
        else:
            log("Invalid installer option for hostname %s!; installer='%s'.\n" % (hostname, installer))

    return 0

def cmd_run(args, config):
    """Run the Robotframework test suites."""

    aklog_workaround_check(args, config)

    # Setup the python paths for our libs and resources.
    sys.path.append(os.path.join(config.get('paths', 'libraries'), 'OpenAFSLibrary'))
    sys.path.append(config.get('paths', 'resources'))

    # Create output dir if needed.
    output = config.optstr('paths', 'output', os.path.join(afsrobot.config.AFS_ROBOTEST_ROOT, "output"))
    mkdirp(output)

    # Verify we have a keytab.
    if not os.path.isfile(config.get('kerberos', 'keytab')):
        sys.stderr.write("Cannot find keytab file '%s'!\n" % (config.get('kerberos', 'keytab')))
        sys.exit(1)

    # Setup the rf options.
    tests = config.get('paths', 'tests') # path to our tests
    options = {
        'variable': [
            'RESOURCES:%s' % config.get('paths', 'resources'), # path to our resources
            'AFS_CELL:%s' % config.get('cell', 'name'),
            'AFS_ADMIN:%s' % config.get('cell', 'admin'),
            'AFS_AKIMPERSONATE:%s' % config.getboolean('kerberos', 'akimpersonate'),
            'KRB_REALM:%s' % config.get('kerberos', 'realm'),
            'KRB_AFS_KEYTAB:%s' % config.get('kerberos', 'keytab'),
        ],
        'report': 'index.html',
        'outputdir': output,
        'loglevel': config.get('run', 'log_level'),
        'exclude': config.get('run', 'exclude_tags').split(','),
        'runemptysuite': True,
        'exitonfailure': False,
    }

    # Additional variables.
    if config.has_section('variables'):
        for o,v in config.items('variables'):
            options['variable'].append("%s:%s" % (o.upper(), v))

    # Additional options.
    if args.suite:
        options['suite'] = args.suite

    if args.include:
        options['include'] = args.include

    # Run the RF tests.
    sys.stdout.write("Running tests.\n")
    code = robot.run(tests, **options)
    if code != 0:
        sys.stderr.write("Tests failed.\n")

    return code

def cmd_web_start(args, config):
    server = afsrobot.web.TinyWebServer(config)
    server.start()

def cmd_web_stop(args, config):
    server = afsrobot.web.TinyWebServer(config)
    server.stop()

def cmd_web_status(args, config):
    server = afsrobot.web.TinyWebServer(config)
    sys.stdout.write("%s\n" % (server.status()))


def cmd_ssh_create(args, config):
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    kwargs = vars(args)
    return afsrobot.ssh.generate_key(keyfile, **kwargs)

def cmd_ssh_dist(args, config):
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    hostnames = config.opthostnames()
    kwargs = vars(args)
    return afsrobot.ssh.distribute_key(keyfile, hostnames, **kwargs)

def cmd_ssh_check(args, config):
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    hostnames = config.opthostnames()
    kwargs = vars(args)
    return afsrobot.ssh.check_access(keyfile, hostnames, **kwargs)

def cmd_ssh_exec(args, config):
    keyfile = config.optstr('ssh', 'keyfile', afsrobot.config.AFS_ROBOTEST_SSH)
    hostnames = config.opthostnames()
    kwargs = vars(args)
    return afsrobot.ssh.execute(keyfile, hostnames, args.command, **kwargs)


def aklog_workaround_check(args, config):
    # Sadly, akimpersonate is broken on the master branch at this time. To
    # workaround this users must setup an aklog 1.6.10+ in some directory
    # and then set a option to specify the location. Since this is easy to
    # get wrong, do a sanity check up front, at least until aklog is fixed.
    import mmap
    import re
    required = (1, 6, 10)
    def _warn():
        sys.stderr.write("Warning: The akimpersonate feature is enabled but the path to a supported\n")
        sys.stderr.write("         aklog is missing.  See the README.md for more information about\n")
        sys.stderr.write("         testing without Kerberos.\n")
    def _fail(msg=None):
        sys.stderr.write("Failed aklog check!\n")
        if msg:
            sys.stderr.write("%s\n" % (msg))
        sys.stderr.write("Please set the aklog option in the [variables] section of the config.\n")
        sys.stderr.write("Require aklog version %d.%d.x " % (required[0:2]))
        sys.stderr.write("and at least version %d.%d.%d.\n" % required)
        sys.exit(1)
    def _find_version(filename):
        with open(filename, "rb") as f:
            mm = mmap.mmap(f.fileno(), 0, prot=mmap.PROT_READ)
            i = mm.find("@(#)")
            if i == -1:
                raise RuntimeError("Unable to find version string.")
            j = mm.find("\0", i)
            if j == -1:
                raise RuntimeError("Unable to find end of version string.")
            version_string = mm[i:j]
            mm.close()
        m = re.match(r'^@\(#\)\s*OpenAFS (\d+)\.(\d+)\.(\d+)', version_string)
        if m is None:
            # We need a valid n.n.n version number (dirty is tolerated)
            raise RuntimeError("Unrecognized version string '%s'." % (version_string))
        return tuple([int(x) for x in m.groups()])
    if config.optbool('kerberos', 'akimpersonate'):
        aklog = config.optstr('variables', 'aklog')
        if aklog is None:
            _warn()
            return
        if not os.access(aklog, os.F_OK):
            _fail("File '%s' not found." % (aklog))
        if not os.access(aklog, os.X_OK):
            _fail("File '%s' not executable." % (aklog))
        try:
            version = _find_version(aklog)
        except RuntimeError as e:
            _fail("Failed to get version number in file %s.\n%s" % (aklog, e))
        if version[0:2] != required[0:2] or version[2] < required[2]:
            msg = "Bad aklog version in file %s; " % (aklog)
            msg += "found version %d.%d.%d in file." % (version)
            _fail(msg)

def main():
    """Command line handling for the afs-robotest tool."""

    def common_options(p):
        p.add_argument('-c', '--config', help="config file", default=None)
        p.add_argument('-v', '--verbose', help="run verbosely", default=False, action='store_true')

    # This should be run as a normal user; sudo is called for installation as needed.
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % (sys.argv[0]))
        sys.exit(1)

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="commands", metavar="<command>")

    #
    # afs-robotest config
    #
    p = subparsers.add_parser('config', help="get or set configuration")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('init', help="create initial config file")
    common_options(p)
    p.add_argument('--newconfig', help="config filename to write", default=None)
    p.set_defaults(_cmd=cmd_config_init)

    p = ssp.add_parser('list', help="show configuration values")
    common_options(p)
    p.add_argument('-x', '--expand', action='store_true', help="expand interpolated values")
    p.add_argument('-s', '--section', help="config section")
    p.set_defaults(_cmd=cmd_config_list)

    p = ssp.add_parser('set', help="set a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.add_argument('value', metavar='<value>', help="option value")
    p.add_argument('--newconfig', help="config filename to write", default=None)
    p.set_defaults(_cmd=cmd_config_set)

    #
    # afs-robotest ssh
    #
    p = subparsers.add_parser('ssh', help="manage ssh keys and run commands")
    ssp = p.add_subparsers(title="actions", metavar="<action>")
    p = ssp.add_parser('create', help="generate a ssh key pair")
    common_options(p)
    p.add_argument('-t', dest='keytype', metavar='<type>', help="ssh key type (default: rsa)", default='rsa')
    p.set_defaults(_cmd=cmd_ssh_create)

    p = ssp.add_parser('dist', help="distribute the ssh public key to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_dist)

    p = ssp.add_parser('check', help="check passwordless ssh access to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_check)

    p = ssp.add_parser('exec', help="execute a command on each remote host")
    common_options(p)
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-q', '--quiet', action='store_true', help="do not print hostnames")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('command', help='command line')
    p.set_defaults(_cmd=cmd_ssh_exec)

    #
    # afs-robotest web
    #
    p = subparsers.add_parser('web', help="run the test report web server")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('start', help="start web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_start)

    p = ssp.add_parser('stop', help="stop web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_stop)

    p = ssp.add_parser('status', help="show web server status")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_status)

    #
    # afs-robotest setup
    #
    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.add_argument('--force', action='store_true', help='overwrite existing files', default=None)
    p.set_defaults(_cmd=cmd_setup)

    #
    # afs-robotest run
    #
    p = subparsers.add_parser('run', help="run the tests")
    common_options(p)
    p.add_argument('-s', '--suite', help="test suite to run (default: all)", default=None)
    p.add_argument('-i', '--include', help="test tags to include (default: all)", default=None)
    p.set_defaults(_cmd=cmd_run)

    #
    # afs-robotest login
    #
    p = subparsers.add_parser('login', help="obtain a token")
    common_options(p)
    p.add_argument('-u', '--user', help="user name (default: admin)", default=None)
    p.set_defaults(_cmd=cmd_login)

    #
    # afs-robotest teardown
    #
    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.set_defaults(_cmd=cmd_teardown)

    args = parser.parse_args()
    try:
        config = afsrobot.config.Config(args.config)  # Optional path to the configuration file.
    except Exception as e:
        sys.stderr.write("Failed reading config file: %s\n" % (e))
        sys.exit(1)

    rc = args._cmd(args, config)
    sys.exit(rc)

if __name__ == "__main__":
    sys.exit(main())

