#!/usr/bin/env python
# Copyright (c) 2015-2017 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import logging
import gettext
import os
import sys
import traceback

import afsrobot.config
import afsrobot.ssh
import afsrobot.web
import afsrobot.runner

import afsutil.system

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)

logger = logging.getLogger('afsrobot')

#
# Environment Variables
#
# AFSROBOT_INI  Fully qualified filename of the configuration file.
#               Defaults to $HOME/afsrobot/afsrobot.ini
#               Overridden by the --config (-c) command line option.
#
AFSROBOT_INI = os.getenv('AFSROBOT_INI',
    os.path.join(os.environ['HOME'], 'afsrobot', 'afsrobot.ini'))

def _print_version(config, **kwargs):
    import afsrobot
    import afsutil
    import OpenAFSLibrary
    sys.stdout.write("afsrobot %s\n" % (afsrobot.__version__))
    sys.stdout.write("afsutil %s\n" % (afsutil.__version__))
    sys.stdout.write("OpenAFSLibrary %s\n" % (OpenAFSLibrary.__version__))

class SubCommandContext(object):
    """Common pre and post processing for each sub-command."""
    def __init__(self, args):
        self.args = args
        # Avoid 'file not found' error when running 'config init'.
        self._defer_config = getattr(args, '_defer_config', False)
        self._logname = getattr(args, '_logname', None)
        self._logfile = None
        self.config = None

    def _read_config(self, filename):
        if not os.path.exists(filename):
            raise ValueError("Config file '%s' not found. Run 'afsrobot.iniig init'." % (filename))
        if self.args.verbose:
            sys.stdout.write("Loading config file %s." % (filename))
        self.config = afsrobot.config.Config()
        self.config.load_from_file(filename)

    def _setup_log(self, config, logname):
        if self.args.debug:
           loglevel = logging.DEBUG
        else:
           loglevel = logging.INFO
        if logname:
            if config:
                logdir = os.path.abspath(self.config.optstr('paths', 'log', '.'))
            else:
                logdir = os.getcwd()
            if not os.path.isdir(logdir):
                os.makedirs(logdir)
            self._logfile = os.path.join(logdir, logname)
            if not self.args.quiet and not self.args.dryrun:
                sys.stdout.write("Writing to log file %s\n" % (self._logfile))
            fmt = '%(asctime)s %(levelname)s %(message)s'
            logging.basicConfig(level=loglevel, filename=self._logfile, format=fmt)
        else:
            fmt = '%(message)s'
            logging.basicConfig(level=loglevel, format=fmt)
        if self.args.verbose:
           console = logging.StreamHandler()
           console.setLevel(loglevel)
           formatter = logging.Formatter('%(message)s')
           console.setFormatter(formatter)
           logging.getLogger('').addHandler(console) # add to the root logger

    def __enter__(self):
        if not self._defer_config:
            self._read_config(self.args.ini)
        self._setup_log(self.config, self._logname)
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is not None and self._logfile:
            sys.stdout.write("See log file %s\n" % (self._logfile))
            if exc_type is afsutil.system.CommandFailed:
                logger.error("Command failed: %s, code %d\n" % (exc_value.cmd, exc_value.code))
                logger.error("output:\n")
                logger.error("%s\n" % (exc_value.out))
            else:
                for line in traceback.format_exception(exc_type, exc_value, tb):
                    logger.error(line.rstrip('\n'))
        return False

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def main():
    """Command line handling for the afsrobot tool."""

    def common_options(p):
        p.add_argument('-c', '--config', dest='ini', metavar='<filename>',
                       help="config file (default: %s)" % AFSROBOT_INI,
                       default=AFSROBOT_INI)
        p.add_argument('-q', '--quiet', help="less messages", default=False, action='store_true')
        p.add_argument('-v', '--verbose', help="show log messages", default=False, action='store_true')
        p.add_argument('--debug', help="debug log level", default=False, action='store_true')

    # This should be run as a normal user; sudo is called for installation as needed.
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % (sys.argv[0]))
        sys.exit(1)

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="commands", metavar="<command>")

    #
    # afsrobot version
    #
    p = subparsers.add_parser('version', help="print version information")
    common_options(p)
    p.set_defaults(_function=_print_version, _defer_config=True)

    #
    # afsrobot init
    #
    p = subparsers.add_parser('init', help="initialize")
    common_options(p)
    p.set_defaults(_function=afsrobot.config.init, _defer_config=True)

    #
    # afsrobot config
    #
    p = subparsers.add_parser('config', help="get or set configuration")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('init', help="create a config file with default values") # alias for init
    common_options(p)
    p.set_defaults(_function=afsrobot.config.init, _defer_config=True)

    p = ssp.add_parser('copy', help="copy configuration values to a new file")
    common_options(p)
    p.add_argument('dest', metavar='<tofile>', help="destination filename")
    p.set_defaults(_function=afsrobot.config.copy)

    p = ssp.add_parser('list', help="show configuration values")
    common_options(p)
    p.add_argument('-r', '--raw', action='store_true', help="do not expand interpolated values")
    p.add_argument('-s', '--section', help="config section")
    p.set_defaults(_function=afsrobot.config.list, out=sys.stdout)

    p = ssp.add_parser('set', help="set a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.add_argument('value', metavar='<value>', help="option value")
    p.set_defaults(_function=afsrobot.config.set)

    p = ssp.add_parser('unset', help="unset a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.set_defaults(_function=afsrobot.config.unset)

    #
    # afsrobot ssh
    #
    p = subparsers.add_parser('ssh', help="manage ssh keys and run commands")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('create', help="generate a ssh key pair")
    common_options(p)
    keyfile = os.path.join(os.environ['HOME'], '.ssh', 'afsrobot')
    p.add_argument('--keyfile', help="ssh keyfile name (default: %s)" % (keyfile), default=keyfile)
    p.add_argument('-t', dest='keytype', metavar='<type>', help="ssh key type (default: rsa)", default='rsa')
    p.set_defaults(_function=afsrobot.ssh.create)

    p = ssp.add_parser('dist', help="distribute the ssh public key to remote hosts")
    common_options(p)
    p.set_defaults(_function=afsrobot.ssh.dist)

    p = ssp.add_parser('check', help="check passwordless ssh access to remote hosts")
    common_options(p)
    p.set_defaults(_function=afsrobot.ssh.check)

    p = ssp.add_parser('exec', help="execute a command on each remote host")
    common_options(p)
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('-l', '--local', action='store_true', help="run the command on the localhost too")
    p.add_argument('command', help='command line')
    p.set_defaults(_function=afsrobot.ssh.execute) # exec is a keyword

    #
    # afsrobot web
    #
    p = subparsers.add_parser('web', help="run the test report web server")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('start', help="start web server")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.start)

    p = ssp.add_parser('stop', help="stop web server")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.stop)

    p = ssp.add_parser('status', help="show web server status")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.status)

    #
    # afsrobot setup
    #
    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.setup, _logname='setup.log')

    #
    # afsrobot test
    #
    p = subparsers.add_parser('test', help="run the tests")
    common_options(p)
    p.add_argument('-s', '--suite', help="test suite to run; e.g. client.basic  (default: all)", default=None)
    p.add_argument('-i', '--include', help="test tags to include (default: all)", default=None)
    p.add_argument('-t', '--test', help="test name to run; e.g. create_a_file (default: all)", default=None)
    p.set_defaults(_function=afsrobot.runner.test)

    #
    # afsrobot login
    #
    p = subparsers.add_parser('login', help="obtain a token")
    common_options(p)
    p.add_argument('-u', '--user', help="user name (default: admin)", default=None)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.login, _logname='login.log')

    #
    # afsrobot teardown
    #
    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.teardown, _logname='teardown.log')

    rc = 0
    args = parser.parse_args()
    try:
        with SubCommandContext(args) as c:
            config = c.config
            kwargs = vars(c.args)
            function = kwargs.pop('_function')
            rc = function(config, **kwargs)
    except afsutil.system.CommandFailed as e:
        sys.stderr.write("Command failed: %s, code %d\n" % (e.cmd, e.code))
        sys.stderr.write("output:\n")
        sys.stderr.write("%s\n" % (e.out))
        if rc == 0:
            rc = 1
    except Exception as e:
        sys.stderr.write("%s\n" % (e))
        if rc == 0:
            rc = 1
    finally:
        pass
    return rc

if __name__ == "__main__":
    sys.exit(main())

