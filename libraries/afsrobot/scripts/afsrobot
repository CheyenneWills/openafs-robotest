#!/usr/bin/python
# Copyright (c) 2015-2017 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import logging
import gettext
import os
import sys

import afsrobot.config
import afsrobot.ssh
import afsrobot.web
import afsrobot.runner

import afsutil.system

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)
#
# AFSROBOT_INI  Fully qualified filename of the configuration file.
#               Defaults to $HOME/afsrobot/afsrobot.ini
#               Overridden by the --config (-c) command line option.
#
AFSROBOT_INI = os.getenv('AFSROBOT_INI',
    os.path.join(os.environ['HOME'], 'afsrobot', 'afsrobot.ini'))

logger = logging.getLogger('afsrobot')

def _set_logging_options(args, config):
    options = {
        'level': logging.INFO,   # default
        'format': '%(message)s', # default
    }

    if args.debug:
        options['level'] = logging.DEBUG
    elif args._section:
        levels = {
            'CRITICAL': logging.CRITICAL,
            'DEBUG': logging.DEBUG,
            'ERROR': logging.ERROR,
            'FATAL': logging.FATAL,
            'INFO': logging.INFO,
            'WARN': logging.WARN,
            'WARNING': logging.WARNING,
        }
        level = config.optstr(args._section, 'loglevel', '').upper()
        if level in levels:
            options['level'] = levels[level]

    # Optional log file (log to stdout if no log file given)
    filename = None
    if args.logfile:
        filename = args.logfile
    elif args._section:
        filename = config.optstr(args._section, 'log')
    if filename:
        filename = os.path.abspath(filename)
        logdir = os.path.dirname(filename)
        options['filename'] = filename
        options['format'] = '%(asctime)s %(levelname)s %(message)s'
        afsutil.system.mkdirp(logdir)
        if args.verbose:
            sys.stdout.write("Writing to log file %s\n" % (filename))

    logging.basicConfig(**options)

    # Also print log messages to stdout when --verbose is given.
    if 'filename' in options and args.verbose:
        formatter = logging.Formatter('%(message)s')
        console = logging.StreamHandler()
        console.setLevel(options['level'])
        console.setFormatter(formatter)
        logging.getLogger('').addHandler(console) # add to the root logger

def _print_version(config, **kwargs):
    import afsrobot
    import afsutil
    import OpenAFSLibrary
    sys.stdout.write("afsrobot %s\n" % (afsrobot.__version__))
    sys.stdout.write("afsutil %s\n" % (afsutil.__version__))
    sys.stdout.write("OpenAFSLibrary %s\n" % (OpenAFSLibrary.__version__))

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def main():
    """Command line handling for the afsrobot tool."""

    def common_options(p):
        p.add_argument('-c', '--config', dest='ini', metavar='<filename>',
                       help="config file (default: %s)" % AFSROBOT_INI,
                       default=AFSROBOT_INI)
        p.add_argument('-q', '--quiet', help="less messages", default=False, action='store_true')
        p.add_argument('-v', '--verbose', help="show log messages", default=False, action='store_true')
        p.add_argument('--debug', help="debug log level", default=False, action='store_true')
        p.add_argument('--logfile', help="log file name", default=None)
        p.set_defaults(_section=None, _defer_config=False)

    # This should be run as a normal user; sudo is called for installation as needed.
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % (sys.argv[0]))
        sys.exit(1)

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="commands", metavar="<command>")

    #
    # afsrobot version
    #
    p = subparsers.add_parser('version', help="print version information")
    common_options(p)
    p.set_defaults(_function=_print_version, _defer_config=True)

    #
    # afsrobot init
    #
    p = subparsers.add_parser('init', help="initialize")
    common_options(p)
    p.set_defaults(_function=afsrobot.config.init, _defer_config=True)

    #
    # afsrobot config
    #
    p = subparsers.add_parser('config', help="get or set configuration")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('init', help="create a config file with default values") # alias for init
    common_options(p)
    p.set_defaults(_function=afsrobot.config.init, _defer_config=True)

    p = ssp.add_parser('list', help="show configuration values")
    common_options(p)
    p.add_argument('section', nargs='?', metavar='<section>', help="section name", default=None)
    p.add_argument('-r', '--raw', action='store_true', help="do not expand interpolated values")
    p.add_argument('-s', '--sections', action='store_true', help="list section names only")
    p.set_defaults(_function=afsrobot.config.list, out=sys.stdout)

    p = ssp.add_parser('set', help="set a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.add_argument('value', metavar='<value>', help="option value")
    p.set_defaults(_function=afsrobot.config.set)

    p = ssp.add_parser('unset', help="unset a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.set_defaults(_function=afsrobot.config.unset)

    #
    # afsrobot ssh
    #
    p = subparsers.add_parser('ssh', help="manage ssh keys and run commands")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('create', help="generate a ssh key pair")
    common_options(p)
    keyfile = os.path.join(os.environ['HOME'], '.ssh', 'afsrobot')
    p.add_argument('--keyfile', help="ssh keyfile name (default: %s)" % (keyfile), default=keyfile)
    p.add_argument('-t', dest='keytype', metavar='<type>', help="ssh key type (default: rsa)", default='rsa')
    p.set_defaults(_function=afsrobot.ssh.create)

    p = ssp.add_parser('dist', help="distribute the ssh public key to remote hosts")
    common_options(p)
    p.set_defaults(_function=afsrobot.ssh.dist)

    p = ssp.add_parser('check', help="check passwordless ssh access to remote hosts")
    common_options(p)
    p.set_defaults(_function=afsrobot.ssh.check)

    p = ssp.add_parser('copy', help="copy a file to each remote host")
    common_options(p)
    p.add_argument('source', help='source filename')
    p.add_argument('dest', help='dest filename')
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('-l', '--local', action='store_true', help="run the command on the localhost too")
    p.set_defaults(_function=afsrobot.ssh.copy)

    p = ssp.add_parser('exec', help="execute a command on each remote host")
    common_options(p)
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('-l', '--local', action='store_true', help="run the command on the localhost too")
    p.add_argument('command', help='command line')
    p.set_defaults(_function=afsrobot.ssh.execute) # exec is a keyword

    #
    # afsrobot web
    #
    p = subparsers.add_parser('web', help="run the test report web server")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('start', help="start web server")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.start)

    p = ssp.add_parser('stop', help="stop web server")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.stop)

    p = ssp.add_parser('status', help="show web server status")
    common_options(p)
    p.set_defaults(_function=afsrobot.web.status)

    #
    # afsrobot setup
    #
    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.setup, _section='setup')

    #
    # afsrobot test
    #
    p = subparsers.add_parser('test', help="run the tests")
    common_options(p)
    p.add_argument('-s', '--suite', help="test suite to run; e.g. client.basic  (default: all)", default=None)
    p.add_argument('-i', '--include', help="test tags to include (default: all)", default=None)
    p.add_argument('-t', '--test', help="test name to run; e.g. create_a_file (default: all)", default=None)
    p.set_defaults(_function=afsrobot.runner.test, _section='test')

    #
    # afsrobot login
    #
    p = subparsers.add_parser('login', help="obtain a token")
    common_options(p)
    p.add_argument('-u', '--user', help="user name (default: admin)", default=None)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.login, _section='login')

    #
    # afsrobot teardown
    #
    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.add_argument('-n', '--dryrun', help="print commands instead of running", default=False, action='store_true')
    p.set_defaults(_function=afsrobot.runner.teardown, _section='teardown')

    args = parser.parse_args()
    config = afsrobot.config.Config()
    if not args._defer_config:
        config.load_from_file(args.ini)
    _set_logging_options(args, config)
    kwargs = vars(args)
    function = kwargs.pop('_function')
    try:
        rc = function(config, **kwargs)
    except afsutil.system.CommandFailed as e:
        sys.stderr.write("Command failed: %s, code %d\n" % (e.cmd, e.code))
        sys.stderr.write("output:\n")
        sys.stderr.write("%s\n" % (e.out))
        rc = e.code
    return rc

if __name__ == "__main__":
    sys.exit(main())

