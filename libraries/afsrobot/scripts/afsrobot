#!/usr/bin/env python
# Copyright (c) 2015-2016 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import logging
import gettext
import os
import sys
import traceback

import afsrobot.config
import afsrobot.ssh
import afsrobot.web
import afsrobot.runner

import afsutil.system

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)

logger = logging.getLogger('afsrobot')

#
# Environment Variables
#
# AFS_ROBOTEST_CONF  Fully qualified filename of the configuration file.
#                    Defaults to $AFS_ROBOTEST_DATA/afs-robotest.conf
#                    Overridden by the --config (-c) command line option.
#
AFS_ROBOTEST_CONF = os.getenv('AFS_ROBOTEST_CONF',
    os.path.join(os.environ['HOME'], '.afsrobotestrc', 'afs-robotest.conf'))

#
# version sub-command
#
def cmd_version(c):
    import afsrobot
    import afsutil
    import OpenAFSLibrary
    sys.stdout.write("afsrobot %s\n" % (afsrobot.__version__))
    sys.stdout.write("afsutil %s\n" % (afsutil.__version__))
    sys.stdout.write("OpenAFSLibrary %s\n" % (OpenAFSLibrary.__version__))

def cmd_init(c):
    userdir = os.path.join(os.environ['HOME'], '.afsrobotestrc')
    if not os.path.isdir(userdir):
        sys.stdout.write("Making user directory %s\n" % (userdir))
        os.makedirs(userdir)
    if os.path.exists(c.args.config):
        _update_config(c.args.config)
    else:
        _create_config(c.args.config)

def _update_config(filename):
    config = afsrobot.config.Config()
    config.load_defaults()
    config.load_from_file(filename)
    sys.stdout.write("Updating config file %s\n" % (filename))
    config.save_as(filename)

def _create_config(filename):
    config = afsrobot.config.Config()
    config.load_defaults()
    if not os.path.isdir(os.path.dirname(filename)):
        sys.stdout.write("Making config file directory %s\n" % (os.path.dirname(filename)))
        os.makedirs(os.path.dirname(filename))
    sys.stdout.write("Creating config file %s\n" % (filename))
    config.save_as(filename)

#
# config sub-commands
#
def cmd_config_init(c):
    cmd_init(c) # alias

def cmd_config_copy(c):
    c.say("Copying to file %s." % (c.args.dest))
    new_config = afsrobot.config.Config()
    new_config.load_from_file(c.config.filename)
    new_config.save_as(c.args.dest)

def cmd_config_list(c):
    c.config.print_values(section=c.args.section, raw=c.args.raw)

def cmd_config_set(c):
    try:
        c.config.set_value(c.args.section, c.args.option, c.args.value)
        c.config.save()
    except Exception as e:
        sys.stderr.write("Unable to set: %s\n" % (e))
        return 1

def cmd_config_unset(c):
    try:
        c.config.unset_value(c.args.section, c.args.option)
        c.config.save()
    except Exception as e:
        sys.stderr.write("Unable to remove: %s\n" % (e))
        return 1

#
# web sub-commands
#
def cmd_web_start(c):
    afsrobot.web.TinyWebServer(c.config).start()

def cmd_web_stop(c):
    afsrobot.web.TinyWebServer(c.config).stop()

def cmd_web_status(c):
    server = afsrobot.web.TinyWebServer(c.config)
    sys.stdout.write("%s\n" % (server.status()))

#
# ssh sub-commands
#
def cmd_ssh_create(c):
    rc = afsrobot.ssh.generate_key(c.args.keyfile)
    if rc == 0:
        c.config.set_value('ssh', 'keyfile', c.args.keyfile)
        c.config.save()
    return rc

def cmd_ssh_dist(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.distribute_key(keyfile, hostnames)

def cmd_ssh_check(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.check_access(keyfile, hostnames)

def cmd_ssh_exec(c):
    keyfile = c.config.optstr('ssh', 'keyfile', required=True)
    hostnames = c.config.opthostnames()
    return afsrobot.ssh.execute(keyfile, hostnames, c.args.command,
                                exclude=c.args.exclude, quiet=c.args.quiet,
                                sudo=c.args.sudo)

def cmd_setup(c):
    r = afsrobot.runner.Runner(c.config)
    r.setup(**vars(c.args))

def cmd_login(c):
    r = afsrobot.runner.Runner(c.config)
    r.login(**vars(c.args))

def cmd_test(c):
    r = afsrobot.runner.Runner(c.config)
    r.test(**vars(c.args))

def cmd_teardown(c):
    r = afsrobot.runner.Runner(c.config)
    r.teardown(**vars(c.args))


class SubCommandContext(object):
    """Common pre and post processing for each sub-command."""
    def __init__(self, args):
        self.args = args
        # Avoid 'file not found' error when running 'config init'.
        self._defer_config = getattr(args, '_defer_config', False)
        self._logname = getattr(args, '_logname', None)
        self._logfile = None
        self.config = None

    def _read_config(self, filename):
        if not os.path.exists(filename):
            raise ValueError("Config file '%s' not found. Run 'afs-robotest config init'." % (filename))
        self.say("Loading config file %s." % (filename))
        self.config = afsrobot.config.Config()
        self.config.load_from_file(filename)

    def _setup_log(self, config, logname):
        if self.args.debug:
           loglevel = logging.DEBUG
        else:
           loglevel = logging.INFO
        if logname:
            if config:
                logdir = os.path.abspath(self.config.optstr('paths', 'log', '.'))
            else:
                logdir = os.getcwd()
            if not os.path.isdir(logdir):
                os.makedirs(logdir)
            self._logfile = os.path.join(logdir, logname)
            if not self.args.quiet:
                sys.stdout.write("Writing to log file %s\n" % (self._logfile))
            fmt = '%(asctime)s %(levelname)s %(message)s'
            logging.basicConfig(level=loglevel, filename=self._logfile, format=fmt)
        else:
            fmt = '%(message)s'
            logging.basicConfig(level=loglevel, format=fmt)
        if self.args.verbose:
           console = logging.StreamHandler()
           console.setLevel(loglevel)
           formatter = logging.Formatter('%(message)s')
           console.setFormatter(formatter)
           logging.getLogger('').addHandler(console) # add to the root logger

    def __enter__(self):
        if not self._defer_config:
            self._read_config(self.args.config)
        self._setup_log(self.config, self._logname)
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is not None and self._logfile:
            sys.stdout.write("See log file %s\n" % (self._logfile))
            if exc_type is afsutil.system.CommandFailed:
                logger.error("Command failed: %s, code %d\n" % (exc_value.cmd, exc_value.code))
                logger.error("output:\n")
                logger.error("%s\n" % (exc_value.out))
                logger.error("error:\n")
                logger.error("%s\n" % (exc_value.err))
            else:
                for line in traceback.format_exception(exc_type, exc_value, tb):
                    logger.error(line.rstrip('\n'))
        return False

    def say(self, msg):
        if self.args.verbose:
            sys.stdout.write("%s\n" % (msg))

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def main():
    """Command line handling for the afsrobot tool."""

    def common_options(p):
        p.add_argument('-c', '--config', metavar='<filename>',
                       help="config file (default: %s)" % AFS_ROBOTEST_CONF,
                       default=AFS_ROBOTEST_CONF)
        p.add_argument('-q', '--quiet', help="less messages", default=False, action='store_true')
        p.add_argument('-v', '--verbose', help="show log messages", default=False, action='store_true')
        p.add_argument('--debug', help="debug log level", default=False, action='store_true')

    # This should be run as a normal user; sudo is called for installation as needed.
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % (sys.argv[0]))
        sys.exit(1)

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="commands", metavar="<command>")

    #
    # afsrobot version
    #
    p = subparsers.add_parser('version', help="print version information")
    common_options(p)
    p.set_defaults(_cmd=cmd_version, _defer_config=True)

    p = subparsers.add_parser('init', help="initialize user directory")
    common_options(p)
    p.set_defaults(_cmd=cmd_init, _defer_config=True)

    #
    # afsrobot config
    #
    p = subparsers.add_parser('config', help="get or set configuration")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('init', help="create a config file with default values") # alias for init
    common_options(p)
    p.set_defaults(_cmd=cmd_config_init, _defer_config=True)

    p = ssp.add_parser('copy', help="copy configuration values to a new file")
    common_options(p)
    p.add_argument('dest', metavar='<tofile>', help="destination filename")
    p.set_defaults(_cmd=cmd_config_copy)

    p = ssp.add_parser('list', help="show configuration values")
    common_options(p)
    p.add_argument('-r', '--raw', action='store_true', help="do not expand interpolated values")
    p.add_argument('-s', '--section', help="config section")
    p.set_defaults(_cmd=cmd_config_list)

    p = ssp.add_parser('set', help="set a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.add_argument('value', metavar='<value>', help="option value")
    p.set_defaults(_cmd=cmd_config_set)

    p = ssp.add_parser('unset', help="unset a configuration value")
    common_options(p)
    p.add_argument('section', metavar='<section>', help="section name")
    p.add_argument('option', metavar='<option>', help="option name")
    p.set_defaults(_cmd=cmd_config_unset)

    #
    # afsrobot ssh
    #
    p = subparsers.add_parser('ssh', help="manage ssh keys and run commands")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('create', help="generate a ssh key pair")
    common_options(p)
    keyfile = os.path.join(os.environ['HOME'], '.ssh', 'afs-robotest')
    p.add_argument('--keyfile', help="ssh keyfile name (default: %s)" % (keyfile), default=keyfile)
    p.add_argument('-t', dest='keytype', metavar='<type>', help="ssh key type (default: rsa)", default='rsa')
    p.set_defaults(_cmd=cmd_ssh_create)

    p = ssp.add_parser('dist', help="distribute the ssh public key to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_dist)

    p = ssp.add_parser('check', help="check passwordless ssh access to remote hosts")
    common_options(p)
    p.set_defaults(_cmd=cmd_ssh_check)

    p = ssp.add_parser('exec', help="execute a command on each remote host")
    common_options(p)
    p.add_argument('-s', '--sudo', action='store_true', help="run remote command as root")
    p.add_argument('-x', '--exclude', metavar='<hosts>', help="hosts to exclude (comma separated)", default='')
    p.add_argument('command', help='command line')
    p.set_defaults(_cmd=cmd_ssh_exec)

    #
    # afsrobot web
    #
    p = subparsers.add_parser('web', help="run the test report web server")
    ssp = p.add_subparsers(title="actions", metavar="<action>")

    p = ssp.add_parser('start', help="start web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_start)

    p = ssp.add_parser('stop', help="stop web server")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_stop)

    p = ssp.add_parser('status', help="show web server status")
    common_options(p)
    p.set_defaults(_cmd=cmd_web_status)

    #
    # afsrobot setup
    #
    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.add_argument('-n', '--dry-run', dest='dryrun', help="Do not run commands", default=False, action='store_true')
    p.add_argument('-s', '--show-commands', dest='showcmds', help="Show commands", default=False, action='store_true')
    p.set_defaults(_cmd=cmd_setup, _logname='setup.log')

    #
    # afsrobot test
    #
    p = subparsers.add_parser('test', help="run the tests")
    common_options(p)
    p.add_argument('-s', '--suite', help="test suite to run (default: all)", default=None)
    p.add_argument('-i', '--include', help="test tags to include (default: all)", default=None)
    p.set_defaults(_cmd=cmd_test)
    # Alias for 'test' for compatibility with old versions.
    if len(sys.argv) > 1 and sys.argv[1] == 'run':
        sys.argv[1] = 'test'

    #
    # afsrobot login
    #
    p = subparsers.add_parser('login', help="obtain a token")
    common_options(p)
    p.add_argument('-u', '--user', help="user name (default: admin)", default=None)
    p.add_argument('-n', '--dry-run', dest='dryrun', help="Do not run commands", default=False, action='store_true')
    p.add_argument('-s', '--show-commands', dest='showcmds', help="Show commands", default=False, action='store_true')
    p.set_defaults(_cmd=cmd_login, _logname='login.log')

    #
    # afsrobot teardown
    #
    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.add_argument('-n', '--dry-run', dest='dryrun', help="Do not run commands", default=False, action='store_true')
    p.add_argument('-s', '--show-commands', dest='showcmds', help="Show commands", default=False, action='store_true')
    p.set_defaults(_cmd=cmd_teardown, _logname='teardown.log')

    rc = 0
    args = parser.parse_args()
    try:
        with SubCommandContext(args) as c:
            rc = args._cmd(c)
    except afsutil.system.CommandFailed as e:
        sys.stderr.write("Command failed: %s, code %d\n" % (e.cmd, e.code))
        sys.stderr.write("output:\n")
        sys.stderr.write("%s\n" % (e.out))
        sys.stderr.write("error:\n")
        sys.stderr.write("%s\n" % (e.err))
        if rc == 0:
            rc = 1
    except Exception as e:
        sys.stderr.write("%s\n" % (e))
        if rc == 0:
            rc = 1
    finally:
        pass
    return rc

if __name__ == "__main__":
    sys.exit(main())

