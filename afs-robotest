#!/usr/bin/env python
# Copyright (c) 2015 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import atexit
import ConfigParser
import gettext
import logging
import os
import signal
import SimpleHTTPServer
import SocketServer
import StringIO
import subprocess
import sys
import time

# Try to give useful messages for non-standard package import errors.
try:
    import afsutil.transarc
    import afsutil.keytab
    import afsutil.init
    import afsutil.cell
except ImportError:
    sys.stderr.write("Cannot import afsutil packages.\n")
    sys.stderr.write("See README for installation instructions.\n");
    sys.exit(1)

try:
    import robot.run
    import robot.libdoc
except ImportError:
    sys.stderr.write("Cannot robotframework packages.\n")
    sys.stderr.write("Install robotframework with `sudo pip install robotframework`.\n")
    sys.exit(1)

try:
    import argparse
except ImportError:
    sys.stderr.write("Cannot import argparse package.\n")
    sys.stderr.write("Install argparse with `sudo pip install argparse`.\n")
    sys.exit(1)

#
# Configuration defaults.
#
DEFAULTS = """
[paths]
dest = %(site)s/dest
doc = %(root)s/doc
site = %(root)s/site
tests = %(root)s/tests
output = %(root)s/output
libraries = %(root)s/libraries
resources = %(root)s/resources

[options]
exclude_tags = todo,crash,slow
log_level = INFO
auto_setup = no
auto_teardown = no

[setup]
dist = transarc

[cell]
name = robotest
user = robotest
admin = robotest.admin

[kerberos]
realm = ROBOTEST
keytab = /tmp/afs.keytab
akimpersonate = yes

[web]
port = 8000
foreground = no
pidfile = /tmp/afs-robotest-web.pid
"""

class SilentRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    """Handle requests without printing messages."""
    def log_message(self, format, *args):
        pass

class TinyWebServer(object):
    """Minimal web server to display test reports and logs.

    This optional helper is provided to avoid apache (or other web server) to
    view the test reports and logs.  This servers static content only.
    """
    def __init__(self, port, docroot, pidfile, foreground):
        self.port = port
        self.docroot = docroot
        self.pidfile = pidfile
        self.foreground = foreground

    def _exit(self):
        """Clean up our pid file."""
        try:
            os.remove(self.pidfile)
        except:
            pass

    def _getpid(self):
        """Get the child process pid from the pid file."""
        pid = 0
        try:
            with open(self.pidfile) as f:
                pid = int(f.readline().strip())
        except:
            pass
        return pid

    def _daemonize(self):
        """Simplified daemonize to run the server in the background."""
        pid = os.fork()
        if pid < 0:
            raise AssertionError("Failed to fork!\n")
        if pid != 0:
            sys.exit(0) # Parent process
        # Child process
        os.setsid() # detach
        atexit.register(self._exit)
        with open(self.pidfile, "w") as f:
            f.write("%d\n" % os.getpid())

    def start(self):
        """Start the miminal web server."""
        pid = self._getpid()
        if pid:
            sys.stderr.write("Already running (pid %d).\n" % (pid))
            return
        if not os.path.exists(self.docroot):
            os.makedirs(self.docroot)
        os.chdir(self.docroot)
        sys.stdout.write("Listening on port %d.\n" % (self.port))
        if not self.foreground:
            self._daemonize()
        address = ('', self.port)
        handler = SilentRequestHandler
        server = SocketServer.TCPServer(address, handler)
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass
        sys.exit(0)

    def stop(self):
        """Stop the miminal web server."""
        if self.foreground:
            sys.stderr.write("Skipping stop; foreground mode.\n")
            return
        pid = self._getpid()
        if pid == 0:
            sys.stdout.write("Not running.\n")
        else:
            sys.stdout.write("Stopping process %d... " % (pid))
            sys.stdout.flush()
            os.kill(pid, signal.SIGINT)
            for _ in xrange(0,10):
                time.sleep(1)
                if self._getpid() == 0:
                    sys.stdout.write("ok.\n")
                    return
            sys.stdout.write("failed.\n")

    def status(self):
        """Get the status of the miminal web server."""
        if self.foreground:
            sys.stderr.write("Skipping status; foreground mode.\n")
            return ""
        pid = self._getpid()
        if pid:
            status = "Process %d listening on port %d." % (pid, self.port)
        else:
            status = "Not running."
        return status

def must_be_root():
    """Fails unless running as root."""
    if os.geteuid() != 0:
        sys.stderr.write("%s: Must run as root!\n" % sys.argv[0])
        sys.exit(1)

def should_not_be_root():
    """Fails if running as root."""
    if os.geteuid() == 0:
        sys.stderr.write("%s: Should not be run as root!\n" % sys.argv[0])
        sys.exit(1)

def cmd_config(args, config):
    """List the current configuration."""
    if args.expand:
        for s in config.sections():
            sys.stdout.write("[%s]\n" % s)
            for k,v in config.items(s):
                sys.stdout.write("%s = %s\n" % (k, v))
            sys.stdout.write("\n")
    else:
        config.write(sys.stdout)

def cmd_setup(args, config):
    """Run the pre-test installation and setup."""
    must_be_root()
    logging.basicConfig(level=logging.INFO)

    dest = config.get('paths', 'dest')
    cell = config.get('cell', 'name')
    admin = config.get('cell', 'admin')
    realm = config.get('kerberos', 'realm')
    keytab = config.get('kerberos', 'keytab')
    akimpersonate = config.get('kerberos', 'akimpersonate')

    # Create a fake key if the keytab does not exist.
    kt = afsutil.keytab.Keytab()
    if akimpersonate:
        kt.add_fake_key("afs/%s@%s" % (cell, realm))
        kt.write(keytab)
    else:
        kt.load(keytab)

    # Install OpenAFS bins.
    installer = afsutil.transarc.TransarcInstaller(dest=dest, cell=cell, realm=realm)
    installer.install()
    kt.set_service_key()

    # Create the test cell.
    afsutil.init.start(components=['server'])
    c = afsutil.cell.Cell(cell=cell, realm=realm, keytab=keytab, admin=admin)
    c.newcell()

    # Setup the root volumes.
    afsutil.init.start(components=['client'])
    if akimpersonate:
        kt.akimpersonate(user=admin, cell=cell, realm=realm)
    else:
        raise AssertionError("not implemented")
    c.mount_root_volumes()
    c.create_top_volumes(['test'])

def cmd_run(args, config):
    """Run the Robotframework test suites."""
    should_not_be_root()
    if config.getboolean('options', 'auto_setup'):
        rc = subprocess.call(['sudo', '-n', sys.argv[0], 'setup'] + sys.argv[2:])
        if rc != 0:
            sys.stderr.write("setup failed!\n")
            sys.exit(1)

    # Setup the python paths for our libs and resources.
    sys.path.append(os.path.join(config.get('paths', 'libraries'), 'OpenAFSLibrary'))
    sys.path.append(config.get('paths', 'resources'))

    # Create output dir if needed.
    output = config.get('paths', 'output')
    if not os.path.exists(output):
        os.makedirs(output)

    # Verify we have a keytab.
    if not os.path.isfile(config.get('kerberos', 'keytab')):
        sys.strerr.write("Cannot find keytab file '%s'!" % (config.get('kerberos', 'keytab')))
        sys.exit(1)

    # Setup the rf options.
    tests = config.get('paths', 'tests') # path to our tests
    options = {
        'variable': [
            'AFS_DIST:%s' %  config.get('setup', 'dist'),
            'AFS_ADMIN:%s' % config.get('cell', 'admin'),
            'AFS_AKIMPERSONATE:%s' % config.getboolean('kerberos', 'akimpersonate'),
            'AFS_CELL:%s' % config.get('cell', 'name'),
            'KRB_REALM:%s' % config.get('kerberos', 'realm'),
            'KRB_AFS_KEYTAB:%s' % config.get('kerberos', 'keytab'),
        ],
        'report': 'index.html',
        'outputdir': output,
        'loglevel': config.get('options', 'log_level'),
        'exclude': config.get('options', 'exclude_tags').split(','),
        'runemptysuite': True,
        'exitonfailure': False,
    }
    rc = robot.run(tests, **options)
    if rc == 0 and config.getboolean('options', 'auto_teardown'):
        rc = subprocess.call(['sudo', '-n', sys.argv[0], 'teardown'] + sys.argv[2:])

    return rc

def cmd_teardown(args, config):
    """Perform the post-test uninstall and cleanup."""
    must_be_root()
    logging.basicConfig(level=logging.INFO)
    afsutil.init.stop(components=['server', 'client'])
    afsutil.transarc.TransarcUninstaller(purge=True).remove()
    return 0

def cmd_web(args, config):
    """Start and stop a minimal web server to view the test reports and logs."""
    should_not_be_root()
    pidfile = config.get('web', 'pidfile')
    port = config.getint('web', 'port')
    docroot = config.get('paths', 'output')
    pidfile = config.get('web', 'pidfile')
    foreground = config.getboolean('web', 'foreground')
    server = TinyWebServer(port, docroot, pidfile, foreground)
    if args.action == 'start':
        server.start()
    elif args.action == 'stop':
        server.stop()
    elif args.action == 'status':
        sys.stdout.write("%s\n" % (server.status()))
    else:
        raise AssertionError("Invalid action: %s" % args.action)
    return 0

def cmd_makedoc(args, config):
    """Generate library documentation."""
    libraries = config.get('paths', 'libraries')
    doc = config.get('paths', 'doc')
    ipath = os.path.join(libraries, 'OpenAFSLibrary', 'OpenAFSLibrary')
    opath = os.path.join(doc, 'OpenAFSLibrary.html')
    sys.path.append(ipath)
    if not os.path.exists(doc):
        os.makedirs(doc)
    try:
        robot.libdoc.libdoc(ipath, opath)
    except (IndexError, KeyError):
        print __doc__

class CommandLineParser(argparse.ArgumentParser):
    """Subclass the argument parser to extend help messages."""
    def __init__(self, *args, **kwargs):
        argparse.ArgumentParser.__init__(self, *args, **kwargs)
    def error(self, message):
        """Display a full usage so all the sub-commands are shown."""
        self.print_help(sys.stderr)
        self.exit(2, gettext.gettext('\n%s: error: %s\n') % (self.prog, message))

def common_options(p):
    p.add_argument('-c', '--config', help="config file", default=None)

def main():

    # Parse command line options.
    parser = CommandLineParser()
    subparsers = parser.add_subparsers(title="sub-commands", metavar="<command>")

    p = subparsers.add_parser('config', help='show configuration')
    common_options(p)
    p.add_argument('-x', '--expand', action='store_true', help="expand interpolated values")
    p.set_defaults(_cmd=cmd_config)

    p = subparsers.add_parser('makedoc', help="generate library documentation")
    common_options(p)
    p.set_defaults(_cmd=cmd_makedoc)

    p = subparsers.add_parser('setup', help='install and setup OpenAFS')
    common_options(p)
    p.set_defaults(_cmd=cmd_setup)

    p = subparsers.add_parser('run', help="run the tests")
    common_options(p)
    p.set_defaults(_cmd=cmd_run)

    p = subparsers.add_parser('teardown', help="remove OpenAFS")
    common_options(p)
    p.set_defaults(_cmd=cmd_teardown)

    p = subparsers.add_parser('web', help="run the test report web server")
    common_options(p)
    p.add_argument('action', choices=['start','stop','status'], help="action to perform")
    p.set_defaults(_cmd=cmd_web)

    args = parser.parse_args()

    # Load configuration. First load defaults then overlay with user defined values.
    config = ConfigParser.SafeConfigParser()
    config.add_section('paths')
    config.set('paths', 'root', os.getcwd())
    config.readfp(StringIO.StringIO(DEFAULTS))
    if args.config:
        with open(args.config, 'r') as f:
            config.readfp(f)

    rc = args._cmd(args, config)
    sys.exit(rc)

if __name__ == "__main__":
    main()
